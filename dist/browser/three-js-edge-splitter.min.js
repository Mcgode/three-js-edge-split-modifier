!(function(t, e) {
"object" == typeof exports && "undefined" != typeof module
? e(exports, require("three"))
: "function" == typeof define && define.amd
? define(["exports", "three"], e)
: e((t.THREEEdgeSplitter = {}), t.THREE);
})(this, function(t, e) {
"use strict";
function r() {
let t = new e.Vector3(),
r = new e.Vector3(),
o = new e.Vector3();
new e.Vector3();
(this._MapPoints = function(t) {
for (let e = 0; e < t.length; e += 3) {
let r = `${t[e]},${t[e + 1]},${t[e + 2]}`;
this._pointMap.has(r) || this._pointMap.set(r, []),
this._pointMap.get(r).push(e / 3);
}
}),
(this._ComputeFaceAreas = function(e) {
this._areas = new Float32Array(e.length / 9);
for (let s = 0; s < e.length; s += 9)
t.set(e[s], e[s + 1], e[s + 2]),
r.set(e[s + 3], e[s + 4], e[s + 5]),
o.set(e[s + 6], e[s + 7], e[s + 8]),
r.sub(t),
o.sub(t),
(this._areas[s / 9] = r.cross(o).length() / 2);
}),
(this._EdgeSplitToGroups = function(e, o, s) {
t
.set(this._normals[3 * s], this._normals[3 * s + 1], this._normals[3 * s + 2])
.normalize();
let i = {splitGroup: [], currentGroup: []};
for (let s of e)
r
.set(this._normals[3 * s], this._normals[3 * s + 1], this._normals[3 * s + 2])
.normalize(),
r.dot(t) < o ? i.splitGroup.push(s) : i.currentGroup.push(s);
return i;
}),
(this._EdgeSplit = function(t, e) {
let s = [];
for (let r of t) s.push(this._EdgeSplitToGroups(t, e, r));
let i = s[0];
for (let t of s) t.currentGroup.length > i.currentGroup.length && (i = t);
o.set(0, 0, 0);
for (let t of i.currentGroup)
r.set(this._normals[3 * t], this._normals[3 * t + 1], this._normals[3 * t + 2]),
o.addScaledVector(r, this._areas[Math.floor(t / 3)]);
o.normalize();
for (let t of i.currentGroup)
(this._normals[3 * t] = o.x),
(this._normals[3 * t + 1] = o.y),
(this._normals[3 * t + 2] = o.z);
i.splitGroup.length && this._EdgeSplit(i.splitGroup, e);
}),
(this.modify = function(t, r) {
(this._pointMap = new Map()),
t.isBufferGeometry || (t = new e.BufferGeometry().fromGeometry(t));
let o = t.getAttribute("position").array;
this._MapPoints(o),
this._ComputeFaceAreas(o),
(this._normals = t.getAttribute("normal").array),
0 ===
new e.Vector3(this._normals[0], this._normals[1], this._normals[2]).length() &&
t.computeVertexNormals(),
(this._normals = t.getAttribute("normal").array);
for (let [t, e] of this._pointMap) this._EdgeSplit(e, Math.cos(r) - 0.001);
return t.setAttribute("normal", new e.BufferAttribute(this._normals, 3, !0)), t;
});
}
(THREE.EdgeSplitModifier = r),
(t.EdgeSplitModifier = r),
Object.defineProperty(t, "__esModule", {value: !0});
});
