!(function (t, i) {
"object" == typeof exports && "undefined" != typeof module
? i(exports, require("three"))
: "function" == typeof define && define.amd
? define(["exports", "three"], i)
: i(
  ((t =
  "undefined" != typeof globalThis
  ? globalThis
  : t || self).THREEEdgeSplitModifier = {}),
  t.THREE
  );
})(this, function (t, i) {
"use strict";
function e() {
let t = new i.Vector3(),
e = new i.Vector3(),
s = new i.Vector3();
new i.Vector3();
(this._MapPoints = function () {
for (let t = 0; t < this._positions.length; t += 3) {
let i = `${this._positions[t]},${this._positions[t + 1]},${
this._positions[t + 2]
}`;
this._pointMap.has(i) || this._pointMap.set(i, []),
this._pointMap.get(i).push(t / 3);
}
}),
(this._ComputeNormals = function () {
this._normals = new Float32Array(3 * this._indexes.length);
for (let i = 0; i < this._indexes.length; i += 3) {
let o = this._indexes[i];
t.set(
this._positions[3 * o],
this._positions[3 * o + 1],
this._positions[3 * o + 2]
),
(o = this._indexes[i + 1]),
e.set(
this._positions[3 * o],
this._positions[3 * o + 1],
this._positions[3 * o + 2]
),
(o = this._indexes[i + 2]),
s.set(
this._positions[3 * o],
this._positions[3 * o + 1],
this._positions[3 * o + 2]
),
s.sub(e),
t.sub(e);
let n = s.cross(t).normalize();
0 === n.length() && console.log("Error computing normal");
for (let t = 0; t < 3; t++)
(this._normals[3 * (i + t)] = n.x),
(this._normals[3 * (i + t) + 1] = n.y),
(this._normals[3 * (i + t) + 2] = n.z);
}
}),
(this._MapPositionsToIndexes = function () {
this._pointToIndexMap = Array(this._positions.length / 3);
for (let t = 0; t < this._indexes.length; t++) {
let i = this._indexes[t];
null == this._pointToIndexMap[i] && (this._pointToIndexMap[i] = []),
this._pointToIndexMap[i].push(t);
}
}),
(this._EdgeSplitToGroups = function (i, s, o) {
t
.set(this._normals[3 * o], this._normals[3 * o + 1], this._normals[3 * o + 2])
.normalize();
let n = {splitGroup: [], currentGroup: [o]};
for (let r of i)
r !== o &&
(e
.set(this._normals[3 * r], this._normals[3 * r + 1], this._normals[3 * r + 2])
.normalize(),
e.dot(t) < s ? n.splitGroup.push(r) : n.currentGroup.push(r));
return n;
}),
(this._EdgeSplit = function (t, i, e = null) {
if (0 === t.length) return;
let s = [];
for (let e of t) s.push(this._EdgeSplitToGroups(t, i, e));
let o = s[0];
for (let t of s) t.currentGroup.length > o.currentGroup.length && (o = t);
null != e && this._splitIndexes.push({original: e, indexes: o.currentGroup}),
o.splitGroup.length && this._EdgeSplit(o.splitGroup, i, e || o.currentGroup[0]);
}),
(this.modify = function (t, e) {
(this._pointMap = new Map()),
t.isBufferGeometry || (t = new i.BufferGeometry().fromGeometry(t)),
null == t.index && (t = i.BufferGeometryUtils.mergeVertices(t)),
(this._indexes = t.index.array),
(this._positions = t.getAttribute("position").array),
this._ComputeNormals(),
this._MapPositionsToIndexes(),
(this._splitIndexes = []);
for (let t of this._pointToIndexMap) this._EdgeSplit(t, Math.cos(e) - 0.001);
let s = new Float32Array(
this._positions.length + 3 * this._splitIndexes.length
);
s.set(this._positions);
let o = this._positions.length,
n = new Uint32Array(this._indexes.length);
n.set(this._indexes);
for (let t = 0; t < this._splitIndexes.length; t++) {
let i = this._splitIndexes[t],
e = this._indexes[i.original];
(s[o + 3 * t] = this._positions[3 * e]),
(s[o + 3 * t + 1] = this._positions[3 * e + 1]),
(s[o + 3 * t + 2] = this._positions[3 * e + 2]);
for (let e of i.indexes) n[e] = o / 3 + t;
}
return (
(t = new i.BufferGeometry()).setAttribute(
"position",
new i.BufferAttribute(s, 3, !0)
),
t.setIndex(new i.BufferAttribute(n, 1)),
t
);
});
}
(THREE.EdgeSplitModifier = e),
(t.EdgeSplitModifier = e),
Object.defineProperty(t, "__esModule", {value: !0});
});
