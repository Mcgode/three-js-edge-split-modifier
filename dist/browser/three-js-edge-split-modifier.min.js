!(function (t, e) {
"object" == typeof exports && "undefined" != typeof module
? e(exports, require("three"))
: "function" == typeof define && define.amd
? define(["exports", "three"], e)
: e(
  ((t =
  "undefined" != typeof globalThis
  ? globalThis
  : t || self).THREEEdgeSplitModifier = {}),
  t.THREE
  );
})(this, function (t, e) {
"use strict";
function i() {
let t = new e.Vector3(),
i = new e.Vector3(),
s = new e.Vector3();
new e.Vector3();
(this._ComputeNormals = function () {
this._normals = new Float32Array(3 * this._indexes.length);
for (let e = 0; e < this._indexes.length; e += 3) {
let o = this._indexes[e];
t.set(
this._positions[3 * o],
this._positions[3 * o + 1],
this._positions[3 * o + 2]
),
(o = this._indexes[e + 1]),
i.set(
this._positions[3 * o],
this._positions[3 * o + 1],
this._positions[3 * o + 2]
),
(o = this._indexes[e + 2]),
s.set(
this._positions[3 * o],
this._positions[3 * o + 1],
this._positions[3 * o + 2]
),
s.sub(i),
t.sub(i);
let n = s.cross(t).normalize();
0 === n.length() && console.log("Error computing normal");
for (let t = 0; t < 3; t++)
(this._normals[3 * (e + t)] = n.x),
(this._normals[3 * (e + t) + 1] = n.y),
(this._normals[3 * (e + t) + 2] = n.z);
}
}),
(this._MapPositionsToIndexes = function () {
this._pointToIndexMap = Array(this._positions.length / 3);
for (let t = 0; t < this._indexes.length; t++) {
let e = this._indexes[t];
null == this._pointToIndexMap[e] && (this._pointToIndexMap[e] = []),
this._pointToIndexMap[e].push(t);
}
}),
(this._EdgeSplitToGroups = function (e, s, o) {
t
.set(this._normals[3 * o], this._normals[3 * o + 1], this._normals[3 * o + 2])
.normalize();
let n = {splitGroup: [], currentGroup: [o]};
for (let r of e)
r !== o &&
(i
.set(this._normals[3 * r], this._normals[3 * r + 1], this._normals[3 * r + 2])
.normalize(),
i.dot(t) < s ? n.splitGroup.push(r) : n.currentGroup.push(r));
return n;
}),
(this._EdgeSplit = function (t, e, i = null) {
if (0 === t.length) return;
let s = [];
for (let i of t) s.push(this._EdgeSplitToGroups(t, e, i));
let o = s[0];
for (let t of s) t.currentGroup.length > o.currentGroup.length && (o = t);
null != i && this._splitIndexes.push({original: i, indexes: o.currentGroup}),
o.splitGroup.length && this._EdgeSplit(o.splitGroup, e, i || o.currentGroup[0]);
}),
(this.modify = function (t, i) {
t.isBufferGeometry || (t = new e.BufferGeometry().fromGeometry(t)),
null == t.index && (t = e.BufferGeometryUtils.mergeVertices(t)),
(this._indexes = t.index.array),
(this._positions = t.getAttribute("position").array),
this._ComputeNormals(),
this._MapPositionsToIndexes(),
(this._splitIndexes = []);
for (let t of this._pointToIndexMap) this._EdgeSplit(t, Math.cos(i) - 0.001);
let s = new Float32Array(
this._positions.length + 3 * this._splitIndexes.length
);
s.set(this._positions);
let o = this._positions.length,
n = new Uint32Array(this._indexes.length);
n.set(this._indexes);
for (let t = 0; t < this._splitIndexes.length; t++) {
let e = this._splitIndexes[t],
i = this._indexes[e.original];
(s[o + 3 * t] = this._positions[3 * i]),
(s[o + 3 * t + 1] = this._positions[3 * i + 1]),
(s[o + 3 * t + 2] = this._positions[3 * i + 2]);
for (let i of e.indexes) n[i] = o / 3 + t;
}
return (
(t = new e.BufferGeometry()).setAttribute(
"position",
new e.BufferAttribute(s, 3, !0)
),
t.setIndex(new e.BufferAttribute(n, 1)),
t
);
});
}
null != THREE && (THREE.EdgeSplitModifier = i),
(t.EdgeSplitModifier = i),
Object.defineProperty(t, "__esModule", {value: !0});
});
